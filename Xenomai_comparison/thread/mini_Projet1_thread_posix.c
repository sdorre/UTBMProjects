/******* need to compile with the option "-lpthread"   ********/

#define NB_DATA 180

#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

void reception_task(int tab[]){
	int i;
	for(i = 0; i<NB_DATA;i++){
		tab[i]=(rand()%180);
	}
}

void computation_task(int *tab1, int *tab2){
	int i;
	for(i=0; i<NB_DATA;i++){
		if (tab1[i]>7){
			tab2[i] = tab1[i];
		} else{
			tab2[i] = 0;
		}
		//printf("%d - ", tab2[i]);
	}
	//printf("\n");
}

void print_task(int *tab){
/**** this task display the obstacle array ****/
	int i;
	char result[NB_DATA];
	for(i=0;i<NB_DATA;i++){
		result[i]=(tab[i]!=0)?' ':'*';
		//printf("%c", result[i]);
	}
	//printf("\n");
}


void* reception_pthread(void);
void* computation_pthread(void);
void* print_pthread(void);


/*************** variable *************************/
pthread_t reception, computation, print_data;
pthread_mutex_t data_tab, obst_tab;
pthread_cond_t new_data, to_print;

//running is the boolean for keeping alive thread
int running=1;
//data_old give an indication to know if data_tab has been already compute by compute_task or not
int data_old=0;

//the 2 tabs of data for the system
int data[NB_DATA];
int obstacle[NB_DATA];


/**************** threads ***************************/
void* reception_pthread(void){
	while(running){
		
		pthread_mutex_lock(&data_tab);
		

		printf("reception task \n");
		reception_task(data);
		data_old=0;


		pthread_mutex_unlock(&data_tab);

		//signaling that the data in tab are updated with new value 
		pthread_cond_signal(&new_data);

		usleep(100000);
	}	
}

void* computation_pthread(void){
	while(running){
		
		pthread_mutex_lock(&data_tab);
		pthread_mutex_lock(&obst_tab);
		

		// if data in the data tab are already read it's waiting until new data arrives
		if(data_old==1){
			printf("... waiting ... tab has no new data\n");
			pthread_cond_wait(&new_data, &data_tab);
		}

		printf("computation task\n");
		computation_task(data, obstacle);
		data_old=1;


		pthread_mutex_unlock(&data_tab);
		pthread_mutex_unlock(&obst_tab);

		//it asks thread to print new obstacles data
		pthread_cond_signal(&to_print);
		
		usleep(250000);
	}
}

void* print_pthread(void){
	while(running){

		pthread_mutex_lock(&obst_tab);


		pthread_cond_wait(&to_print, &obst_tab);
		printf("print task\n");
		print_task(obstacle);


		pthread_mutex_unlock(&obst_tab);
	}
}




int main(int argc, char* argv[]){

	if (argc<2){
		printf("arguments not found - usage : exec <tps in sec>\n");
		return 1;
	}

	printf("beginning main Thread.\n");
	
	int temp = atoi(argv[1]);

	// we give a constant time_t in order to have always the same data generated by generation Task
	time_t today_time = 1397131000;
	srand(today_time);
	
	// initialize mutex and conditions
	if ((pthread_mutex_init(&data_tab, NULL) != 0) &&( pthread_mutex_init(&obst_tab, NULL) != 0)	 ){
		printf("\n mutex init failed.\n");
		return 1;
	}
	
	if((pthread_cond_init(&new_data, NULL) != 0) || (pthread_cond_init(&to_print, NULL))){
		printf("\n initialisation of condition failed.\n");
	
	}

	// creation of the differents threads
	pthread_create(&reception, NULL, &reception_pthread, NULL);
	pthread_create(&computation, NULL, &computation_pthread, NULL);
	pthread_create(&print_data, NULL, &print_pthread, NULL);
	
	// the main thread had to wait a little and then stop child threads
	printf("sleeping %ds ...\n", temp);
	
	sleep(temp);
	printf("...stopping threads !\n");
	
	running=0;
	
	pthread_join(reception, NULL);
    pthread_join(computation, NULL);
    pthread_join(print_data, NULL);
    pthread_mutex_destroy(&data_tab);
    pthread_mutex_destroy(&obst_tab);
    
	printf("end of the main Thread\n");
	return 0;
}
